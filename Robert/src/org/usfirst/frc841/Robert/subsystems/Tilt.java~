// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc841.Robert.subsystems;

import java.util.Timer;
import java.util.TimerTask;

import org.usfirst.frc841.Robert.RobotMap;
import org.usfirst.frc841.Robert.commands.*;
import org.usfirst.frc841.Robert.lib.PIDLoop;
import org.usfirst.frc841.Robert.subsystems.Elevator.Update;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Tilt extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController tiltMotor = RobotMap.tiltTiltMotor;
    AnalogInput  TiltAngleSensor = RobotMap.tiltTiltAngleSensor;
    DigitalInput hardStopFront = RobotMap.tiltHardStopFront;
    DigitalInput hardStopBack = RobotMap.tiltHardStopBack;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  
    private double Y[] = {0,0,0};
  	private double X[] = {0,1,2};
  	private int period = 100; //mSec 
  	private double kp = 8;
  	private double ki = 0.01;
  	private double kd = .25;
  	private double Setpoint = 0.223;
  	private boolean EnablePID = false;
  	private boolean reachDestination = false;
 
 
  	Timer ControllerTimer;
  	PIDLoop cloop;
    
     
    //Creates a new timer at the desired time
    public Tilt(){
    
    	cloop = new PIDLoop(X,Y);
   	 	cloop.SetControllerDirection(true);
   	 	cloop.SetOutputLimits(-1, 1);
   	 	cloop.SetSampleTime((long) period);
   	 	cloop.SetReference(Setpoint);
   	 	cloop.SetTunings(kp, ki, kd);// PID Tuning values
   	 
    	 
    	 
    	 ControllerTimer = new Timer();
    	 ControllerTimer.schedule(new Update(this), 0L, period); // schedule PID
     }
     
     	class Update extends TimerTask{
    	 	private Tilt tilt;
    	    	
    	    	public Update(Tilt tilt){
    	    		this.tilt = tilt; 
    	 
    	    	}
    			@Override
    			public void run() {
    				// TODO Auto-generated method stub
    				//Implements PID Loop
    				tilt.EnablePID = true;
    				if (tilt.EnablePID){
    					tilt.cloop.SetTunings(tilt.kp,tilt.ki,tilt.kd);
    					tilt.cloop.SetReference(Setpoint);
    					tilt.SetMotors(tilt.cloop.Compute(tilt.GetAngle()));
    					
    					if ( (Setpoint - (Setpoint* 0.03)) < tilt.GetAngle() && tilt.GetAngle() < (Setpoint + (Setpoint* 0.03))){
    						reachDestination = true;
    					}
    					else{
    						reachDestination = false;
    					}
    				}
   
    			}
    	    }
     	 public void updatePIDValues(double _kp,double _ki, double _kd){
          	kp = _kp;
          	ki = _ki;
          	kd = _kd;
          }
          public void enableControlLoop(){
          	EnablePID = true;
          }
          public void disableControlLoop(){
          	EnablePID = false;
          }
          public void SetGoal(double goal){
          	
          	Setpoint = goal;
          		
          }
          public boolean reachDestination() {
           	return reachDestination;
           }
    	
    
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    public void SetMotors(double power) {
    	//if(hardStopFront.get() || hardStopBack.get()){
    	//	tiltMotor.set(0);
    	//}
    	//else{
    		tiltMotor.set(-power);
    	//}
    	
    }
    public double GetAngle() {
    	return TiltAngleSensor.getVoltage();
    }
}

