// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc841.Robert.subsystems;

import org.usfirst.frc841.Robert.RobotMap;
import org.usfirst.frc841.Robert.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Compressor compressor1 = RobotMap.driveTrainCompressor1;
    SpeedController leftDrive1 = RobotMap.driveTrainLeftDrive1;
    SpeedController rightDrive1 = RobotMap.driveTrainRightDrive1;
    SpeedController leftDrive2 = RobotMap.driveTrainLeftDrive2;
    SpeedController rightDrive2 = RobotMap.driveTrainRightDrive2;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  //Variables used for Cheesy Poofs Drive Style
    boolean isHighGear = false;
    private double oldwheel = 0.0;
    private double quickstopaccumlator = 0;
    private double throottleDeadband = 0.02;
    private double wheelDeadband = 0.02;
    private double SensitivtyHigh = 0.85;
    private double SensitityLow = 0.75;
    private boolean isQuickTurn = false;
    private boolean isStraight = false;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        
        
    }
public void Drive(Joystick stick){
        
        //cheesyDrive(stick);
        tankDrive(stick);
        
    }
    //Set the power on the left and right motor drive
    public void SetLeftRight(double LPower, double RPower){
    	leftDrive1.set(LPower);
    	leftDrive2.set(LPower);
    	rightDrive1.set(RPower);
    	rightDrive2.set(RPower);
    }
    //Shift drive to high gear and update memory
    public void SetHighGear(){
    	isHighGear = true;
    }
    //Shift drive train to low gear and update memory
    public void SetLowGear(){
    	isHighGear = false;
    }
    //returns the Yaxis value of te left joystck
    public double getThrottle(Joystick stick){
    	return stick.getY();
    }
    //returns the Xaxis value of the right joystick
    public double getWheel(Joystick stick){
        return stick.getZ();
    }
  //returns the Yaxis value of the left joystick
    public double getYAxisLeftSide(Joystick stick){
        return stick.getY();
    }
  //returns the Yaxis value of the right joystick
    public double getYAxisRightSide(Joystick stick){
        return stick.getThrottle();
    }

    //Tank drive style code
    public void tankDrive(Joystick stick){
        double axisNonLinearity;
        //Get Y axis and make a deadband 
        double leftY =  handleDeadband(getYAxisLeftSide(stick),0.02);
        double rightY =  handleDeadband(getYAxisRightSide(stick),0.02);
        
        
         if (isHighGear) {
            axisNonLinearity = 0.5;
            // Smooth the controls on Left side
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
         
            //Smooth the controls on Right side
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            }
            else{
                axisNonLinearity = 0.5;
            // Smooth the controls on Left side
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
         
            //Smooth the controls on Right side
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            }
        
            //set the motors
            SetLeftRight(leftY,rightY);
        
    }
    //If the value is too small make it zero. 
    public double handleDeadband(double val, double deadband) {
        return (Math.abs(val) > Math.abs(deadband)) ? val : 0.0;
    }
    public static double limit(double v, double limit) {
        return (Math.abs(v) < limit) ? v : limit * (v < 0 ? -1 : 1);
    }
    public void InitCompressor(){
    	this.compressor1.enabled();
    }
}

