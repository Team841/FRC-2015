// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc841.Robert.subsystems;

import java.nio.file.Path;
import java.util.Timer;
import java.util.TimerTask;


//import org.usfirst.frc841.Robert.FalconPathPlanner;
import org.usfirst.frc841.Robert.*;
import org.usfirst.frc841.Robert.commands.*;
import org.usfirst.frc841.Robert.lib.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Compressor compressor1 = RobotMap.driveTrainCompressor1;
    SpeedController leftDrive1 = RobotMap.driveTrainLeftDrive1;
    SpeedController rightDrive1 = RobotMap.driveTrainRightDrive1;
    Encoder leftQuad = RobotMap.driveTrainLeftQuad;
    Encoder rightQuad = RobotMap.driveTrainRightQuad;
    SpeedController leftDrive2 = RobotMap.driveTrainLeftDrive2;
    SpeedController rightDrive2 = RobotMap.driveTrainRightDrive2;
    DoubleSolenoid shifter = RobotMap.driveTrainShifter;
    Gyro gyro1 = RobotMap.driveTrainGyro1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    
    //trajectory
    ///
    /////////
	//create waypoint path

	double[][] waypoints = new double[][]{

	    {3.745, 4.5},

	    {3.5, 5},

	    {5.5,8},

	    {5.5, 9.5},

	    {4.8, 11.5},

	    {1.5, 15},

	    {2.8, 20},

	    {7,22},

	    {15, 22}

	}; 



	double totalTime = 12; //max seconds we want to drive the path

	double timeStep = 0.1; //period of control loop on Rio, seconds

	double robotTrackWidth = 2.167; //distance between left and right wheels, feet

	FalconPathPlanner path  = new FalconPathPlanner(waypoints);
	
	
    private double Y[] = {1,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0,-0.1,-0.2,-0.3,-0.4,-0.5,-0.6,-0.7,-0.8,-0.9,-1};
	// private double X[] = {-9,-8,-7,-6,-5.15,-4.15,-3.25,-2.4,-1.41,-0.36,0,0.72,2.83,4.8,6.5,8.3,10.3,12,14,16,18};
    //private double Y[] = {-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3};
  	private double X[] = {-18,-16,-14,-12,-10.3,-8.3,-6.5,-4.8,-2.83,-0.72,0,0.72,2.83,4.8,6.5,8.3,10.3,12,14,16,18};
  	private int period = 100; //mSec 
  	private double kp = 0.1; // P
  	private double ki = 0.00; // I
  	private double kd = 0.0; // D
  	private double Setpoint = 3.107; //goal
  	private boolean EnablePID = false; // PID loop enable 
  	private boolean reachDestination = false; // PID within range
  	private int counter1 = 0;
  	private double PIDOutput = 0;
    Timer ControllerTimer;
 	 PIDLoop cloop;
 	 
  
   	private double Setpoint2 = 3.107; //goal
   	private boolean EnablePID2 = false; // PID loop enable 
   	private boolean reachDestination2 = false; // PID within range
 	PIDLoop cloop2;
 	 
 	 public DriveTrain () {
 		 
 		 //FalconPathPlanner path = new FalconPathPlanner(waypoints);
 		 path.calculate(totalTime, timeStep, robotTrackWidth);
 		 cloop = new PIDLoop(X,Y);
 		 cloop.SetControllerDirection(true);
 		 cloop.SetOutputLimits(-1, 1);
 		 cloop.SetSampleTime((long) period);
 		 cloop.SetReference(Setpoint);
 		 cloop.SetTunings(kp, ki, kd);// PID Tuning values
   	 
 		 cloop2 = new PIDLoop(X,Y);
 		 cloop2.SetControllerDirection(true);
 		 cloop2.SetOutputLimits(-1, 1);
 		 cloop2.SetSampleTime((long) period);
 		 cloop2.SetReference(Setpoint2);
 		 cloop2.SetTunings(kp, ki, kd);// PID Tuning values
   	 
 		 ControllerTimer = new Timer();
 		 ControllerTimer.schedule(new Update(this), 0L, period); // schedule PID
 	 }
 	 class Update extends TimerTask{
	 	private DriveTrain drivetrain;
	    	
	    	public Update(DriveTrain drivetrain){
	    		this.drivetrain = drivetrain; 
	 
	    	} 
			@Override
			public void run() {
			//	claw.EnablePID = true; // test PID loop. This should be commented out.
				// TODO Auto-generated method stub
				if(drivetrain.EnablePID){
					double input,input2;
					input = drivetrain.getLeftSpeed();
					input2 = drivetrain.getRightSpeed();
					
					drivetrain.cloop.SetTunings(2*drivetrain.kp,drivetrain.ki,drivetrain.kd);
					drivetrain.cloop2.SetTunings(2*drivetrain.kp,drivetrain.ki,drivetrain.kd);
					
					drivetrain.cloop.SetReference(-drivetrain.path.smoothLeftVelocity[drivetrain.counter1][1]);
					drivetrain.cloop2.SetReference(-drivetrain.path.smoothRightVelocity[drivetrain.counter1][1]);
				
					drivetrain.SetLeftRight( drivetrain.cloop.Compute(input), -drivetrain.cloop2.Compute(input2) );//.SetMotors(claw.cloop.Compute(input));
				
					if(drivetrain.counter1 >= (drivetrain.path.smoothLeftVelocity.length -1)){
						drivetrain.counter1 = 0;
						drivetrain.EnablePID = false;
						drivetrain.SetLeftRight(0, 0);
					}
					drivetrain.counter1++;
				}

			}
				
	 }
	
   public void updatePIDValues(double _kp,double _ki, double _kd){
    	kp = _kp;
    	ki = _ki;
    	kd = _kd;
    }
    public void enableControlLoop(){
    	EnablePID = true;
    	counter1 = 0;
    }
    public void disableControlLoop(){
    	EnablePID = false;
    }
    public void SetGoalL(double goal){
    	//reachDestination = false;
    	Setpoint = goal;
		EnablePID = true;
    		
    }
    public void SetGoalR(double goal){
    	reachDestination2 = false;
    	Setpoint2 = goal;
		EnablePID = true;
    		
    }
    public void clear(){
   	 reachDestination = false;
   	 reachDestination2 = false;
    }
    public boolean isReachDestinationL() {
    	return reachDestination;
    }
    public boolean isReachDestinationR() {
    	return reachDestination2;
    }

   

  //Variables used for Cheesy Poofs Drive Style
 
    boolean isHighGear = false;
    private double oldWheel = 0.0;
    private double quickStopAccumulator = 0;
    private double throttleDeadband = 0.02;
    private double wheelDeadband = 0.02;
    private double sensitivityHigh = 0.85; 
    private double sensitivityLow = 0.75;
    private boolean isQuickTurn = false;
    private boolean isStraight = false;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        
        
    }
public void Drive(Joystick stick){
        if (!this.EnablePID){
        cheesyDrive(stick);
        //tankDrive(stick);
        }
    }
    //Set the power on the left and right motor drive
    public void SetLeftRight(double LPower, double RPower){
    	this.PIDOutput = LPower; 
    	leftDrive1.set(LPower);
    	leftDrive2.set(LPower);
    	rightDrive1.set(RPower);
    	rightDrive2.set(RPower);
    }
    //Shift drive to high gear and update memory
    public void SetHighGear(){
    	shifter.set(DoubleSolenoid.Value.kReverse);
    	isHighGear = true;
    }
    //Shift drive train to low gear and update memory
    public void SetLowGear(){
    	shifter.set(DoubleSolenoid.Value.kForward);
    	isHighGear = false;
    }
    //returns the Yaxis value of te left joystck
    public double getThrottle(Joystick stick){
    	return stick.getY();
    }
    //returns the Xaxis value of the right joystick
    public double getWheel(Joystick stick){
        return stick.getZ();
    }
  //returns the Yaxis value of the left joystick
    public double getYAxisLeftSide(Joystick stick){
        return stick.getY();
    }
  //returns the Yaxis value of the right joystick
    public double getYAxisRightSide(Joystick stick){
        return stick.getThrottle();
    }

    //Tank drive style code
    public void tankDrive(Joystick stick){
        double axisNonLinearity;
        //Get Y axis and make a deadband 
        double leftY =  handleDeadband(getYAxisLeftSide(stick),0.02);
        double rightY =  handleDeadband(getYAxisRightSide(stick),0.02);
        
        
         if (isHighGear) {
            axisNonLinearity = 0.5;
            // Smooth the controls on Left side
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
         
            //Smooth the controls on Right side
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            }
            else{
                axisNonLinearity = 0.5;
            // Smooth the controls on Left side
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            leftY = Math.sin(Math.PI / 2.0 * axisNonLinearity * leftY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
         
            //Smooth the controls on Right side
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            rightY = Math.sin(Math.PI / 2.0 * axisNonLinearity * rightY) /
                Math.sin(Math.PI / 2.0 * axisNonLinearity);
            }
        
            //set the motors
            SetLeftRight(leftY,rightY);
        
    }
    
    //Enable quick turn AKA classical Archade drive
    public void setQuickTurn(){
    isQuickTurn = true;
    }
    //Disable quick turn
    public void resetQuickTurn(){
    isQuickTurn = false;
    }
    //Slim down version of the Cheesy Poofs drive style.
    public void cheesyDrive(Joystick stick){
        
        //Note quickturn and shift is taken care of with buttons in OI.
        
        double wheelNonLinearity;
        double wheel = handleDeadband(getWheel(stick),wheelDeadband); //double wheel = handleDeadband(controlBoard.rightStick.getX(), wheelDeadband);
        double throttle = - handleDeadband(getThrottle(stick),throttleDeadband);
        double negInertia = wheel - oldWheel;
       /* 
        if(getAverageSpeed()> 2000){
            SetHighGear();
        }
        else if (getAverageSpeed() < 1500){
          SetLowGear();
        }
         */  
                
        oldWheel = wheel;
        if (isHighGear) {
            wheelNonLinearity = 0.6;
            // Apply a sin function that's scaled to make it feel better.
            wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) /
            Math.sin(Math.PI / 2.0 * wheelNonLinearity);
            wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) /
            Math.sin(Math.PI / 2.0 * wheelNonLinearity);
        } else {
            wheelNonLinearity = 0.5;
            // Apply a sin function that's scaled to make it feel better.
            wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) /
            Math.sin(Math.PI / 2.0 * wheelNonLinearity);
            wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) /
            Math.sin(Math.PI / 2.0 * wheelNonLinearity);
            wheel = Math.sin(Math.PI / 2.0 * wheelNonLinearity * wheel) /
            Math.sin(Math.PI / 2.0 * wheelNonLinearity);
        }
        
        double leftPwm, rightPwm, overPower;
        double sensitivity = 1.7;
        double angularPower;
        double linearPower;
        // Negative inertia!
        double negInertiaAccumulator = 0.0;
        double negInertiaScalar;
        
        
        if (isHighGear) {
            negInertiaScalar = 5.0;
            sensitivity = sensitivityHigh; //sensitivity = Constants.sensitivityHigh.getDouble();
        } else {
            if (wheel * negInertia > 0) {
                negInertiaScalar = 2.5;
            } else {
                if (Math.abs(wheel) > 0.65) {
                    negInertiaScalar = 5.0;
                } else {
                    negInertiaScalar = 3.0;
                }
            }
            sensitivity = sensitivityLow;   //sensitivity = Constants.sensitivityLow.getDouble();
            if (Math.abs(throttle) > 0.1) {
       // sensitivity = 1.0 - (1.0 - sensitivity) / Math.abs(throttle);
            }
        }
        
        
        double negInertiaPower = negInertia * negInertiaScalar;
        negInertiaAccumulator += negInertiaPower;
        wheel = wheel + negInertiaAccumulator;
        if (negInertiaAccumulator > 1) {
            negInertiaAccumulator -= 1;
        } else if (negInertiaAccumulator < -1) {
            negInertiaAccumulator += 1;
        } else {
            negInertiaAccumulator = 0;
        }
        linearPower = throttle;
        // Quickturn!
        if (isQuickTurn) {
            if (Math.abs(linearPower) < 0.2) {
                double alpha = 0.1;
                quickStopAccumulator = (1 - alpha) * quickStopAccumulator + alpha * limit(wheel, 1.0) * 5;
            }
            overPower = 1.0;
            if (isHighGear) {
                sensitivity = 1.0;
            } else {
                sensitivity = 0.5;
                
            }
            angularPower = wheel;
        } else {
            overPower = 0.0;
            angularPower = Math.abs(throttle) * wheel * sensitivity - quickStopAccumulator;
            if (quickStopAccumulator > 1) {
                quickStopAccumulator -= 1;
            } else if (quickStopAccumulator < -1) {
                quickStopAccumulator += 1;
            } else {
                quickStopAccumulator = 0.0;
            }
        }
        rightPwm = leftPwm = linearPower;
        leftPwm += angularPower;
        rightPwm -= angularPower;
        if (leftPwm > 1.0) {
            rightPwm -= overPower * (leftPwm - 1.0);
            leftPwm = 1.0;
        } else if (rightPwm > 1.0) {
            leftPwm -= overPower * (rightPwm - 1.0);
        rightPwm = 1.0;
        } else if (leftPwm < -1.0) {
            rightPwm += overPower * (-1.0 - leftPwm);
            leftPwm = -1.0;
        } else if (rightPwm < -1.0) {
            leftPwm += overPower * (-1.0 - rightPwm);
            rightPwm = -1.0;
        } 
        SetLeftRight(leftPwm,-rightPwm);
        
    }   

    //If the value is too small make it zero. 
    public double handleDeadband(double val, double deadband) {
        return (Math.abs(val) > Math.abs(deadband)) ? val : 0.0;
    }
    public static double limit(double v, double limit) {
        return (Math.abs(v) < limit) ? v : limit * (v < 0 ? -1 : 1);
    }
    public void InitCompressor(){
    	this.compressor1.enabled();
    }
  
  //Settings for Quadrature Encoders;  
  private double MaxPeriod = 0.1;
  private double MinRate = 10;
  private int AverageSamples = 7;
  private double wheelDiameter = 5;
  private double DistancePerPulse  = (Math.PI * wheelDiameter)/ 255/ 12;
  
  //Initialize the Quardrature encoders for measurments
  public void initEncoder(){
	  //Set Direction
	  leftQuad.setReverseDirection(true);
	  rightQuad.setReverseDirection(false);
	  
	  //Set rate
	  leftQuad.setDistancePerPulse(DistancePerPulse);
	  rightQuad.setDistancePerPulse(DistancePerPulse);
	  
	  //Reset Quad;
	  leftQuad.reset();
	  rightQuad.reset();
	 
  }

  public double getLeftEncoderDistance(){
	  return leftQuad.get() / 255.00 * wheelDiameter * Math.PI;
  }
  public double getRightEncoderDistance(){
	  return rightQuad.get() / 255.00 * wheelDiameter * Math.PI;
  }
  public void resetEncoders(){
	  //Reset Quad;
	  leftQuad.reset();
	  rightQuad.reset();
  }
  public double getAverageSpeed(){
	  double left = 0;
	  double right = 0;
	  double average = 0;
	  left = leftQuad.getRate();
	  right = rightQuad.getRate();
	  
	  average = Math.abs((right + left)/2);
	  return average;
  }
  public double getLeftSpeed(){
	  return leftQuad.getRate();
  }
  public double getRightSpeed(){
	  return rightQuad.getRate();
  }
  public double getOutput(){
	  return this.path.smoothLeftVelocity[counter1][1];
  }
 
  public int getCount(){
	  return this.counter1;
  }
}

